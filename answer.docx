# midterm_887342


11.) Version control คือ ระบบที่จัดเก็บการเปลี่ยนแปลงที่เกิดขึ้นกับไฟล์หนึ่งหรือหลายไฟล์เพื่อที่คุณสามารถเรียกเวอร์ชั่นใดเวอร์ชั่นหนึ่งกลับมาดูเมื่อไรก็ได้ หนังสือเล่มนี้จะยกตัวอย่างจากไฟล์ที่เป็นซอร์สโค้ดของซอฟต์แวร์ แต่ขอให้เข้าใจว่าจริง ๆ แล้วคุณสามารถใช้ version control กับไฟล์ชนิดใดก็ได้
- มีการเก็บ code เก่าๆไว้ให้ด้วย ไม่ต้อง สำเนาเอง
- มีการบอกด้วยว่า ลบอะไรเข้าไป เพิ่มอะไรเข้ามา
- มี Timeline บอกด้วยนะ ว่าวันไหนทำเยอะ วันไหนทำน้อย
- มีgraph บอกด้วยนะว่าเราเขียนภาษาอะไรเยอะแค่ไหน
12.) 1. ทั้ง SCCS, RCS, CVS, SVN ที่กล่าวในช่วงแรกทั้งหมดนั้นใช้ central code repository model คือหมายความง่ายๆ ว่า changes ของ file ทั้งหมดถูกเก็บอยู่ที่ central repo หรือศูนย์กลางที่เดียว ถ้าสมมติว่า central repo เกิดพังขึ้นมาหรือผู้ใช้ไม่สามารถติดต่อกับ central repo ได้ก็จะทำให้ไม่สามารถดึงไฟล์ที่พึ่งเปลี่ยนแปลงมาทีตัวเองได้
2. ส่วน distributed version control ที่ใช้ใน BitKeeper และ git นั้น แต่ละคนจะมี copy ของไฟล์ตั้งแต่เริ่มแรกจนท้ายสุด ดังนั้นแต่ละทีมหรือแต่ละคนสามารถ maintain code ได้โดยที่ทุกคนมี copy ของไฟล์ทั้งหมดอยู่ที่ local computer และ change set ของแต่ละ version ที่เกิดขึ้นจากหลายๆ ทีมนั้นสามารถรวมกันได้ ไม่จำเป็นต้องรอ changes copy จาก central repo อีกต่อไป
3. ดังนั้น distributed version control จึงเร็วกว่า และผู้ใช้งานก็สามารถแก้ได้ทุกที่ โดยไม่จำเป็นจะต้องติดต่อกับ central repo ก็ได้
4. นอกจากนี้เรายังสามารถ fork projects ได้ด้วย แปลง่ายๆ คือดึงโปรเจกต์มาอยู่ในชื่อเราเพื่อแก้ไขในแบบที่เราต้องการหรือใช้สำหรับแก้โค้ดและส่งกลับไปให้กับเจ้าของที่พัฒนาโค้ดก็ได้ การ fork ในที่นี้คือการยอมให้ outside developers นำโค้ดของผู้พัฒนาไปแก้และ pull request กลับไปให้ผู้พัฒนานั่นเอง
13.) ทุกๆคนในทีมจะรู้ว่าคนอื่นๆในทีมที่เหลือกำลังทำอะไรอยู่ส่วนผู้ที่ดูแลระบบก็สามารถจัดการกับสิทธิ์การทำงานของ user ทุกคนได้ซึ่งนี้ก็เป็นข้อดีที่เหนือกว่าการมานั่งกำหนดอะไรอะไรที่ local database ทีละเครื่องมากมายนัก
14.) 1. ทำการ Merge บ่อย ๆ
	ปัญหาใหญ่ ๆ ของ Merge conflict เกิดจากจำนวน source code ที่ชนหรือขัดแย้งกันมากเหลือเกิน
2. เล็ก ๆ สิดี
ว่าด้วยเรื่องของ Single Responsibility Principle (SRP)เป็นหนึ่งในแนวทางการออกแบบระบบงานที่ดี คือ SOLID
3. การพูดคุย การสื่อสาร มันสำคัญอย่างมาก
	แต่ละคนในทีมพูดคุยกันหรือไม่ ?แต่ละคนในทีมรู้หรือไม่ว่า เพื่อน ๆ แต่ละคนทำงานอะไร ? รู้หรือไม่ว่า แต่ละคนแก้ไข class อะไรกันอยู่ ? รู้หรือไม่ว่า สิ่งที่แก้ไขไปนั้นกระทบใครบ้าง ?
4. Mob programming
	เป็นวิธีการที่ทรงประสิทธิภาพอย่างมากและเชื่อได้เลยว่า แก้ไขปัญหา Merge conflict ได้ 100% เนื่องจากทุกคนมานั่งทำงานด้วยกันใช้เครื่องทำงานเดียวกันดังนั้น ไม่มีทางที่ source code จะขัดแย้งกัน
	แต่มันมีค่าใช้จ่ายที่สูงมาก ๆดังนั้นจึงเป็นวิธีการสุดท้ายที่จะทำนั่นเอง
15.) 1. ให้ทำการ merge บ่อย ๆ ไปเลยนั่นคือ ทุกครั้งเมื่อคุณทำการเปลี่ยนแปลง หรือ commit source code นั่นเองจะช่วยลดข้อขัดแย้งต่าง ๆ ลงไปอย่างมากถึงจะเกิดข้อขัดแย้ง ก็เป็นเพียงปัญหาเล็ก ๆซึ่งสามารถแก้ไขได้อย่างง่ายดาย
2. การออกแบบที่ดีมันช่วยให้ทีมทำงานร่วมกันได้อย่างดียิ่งแต่ละส่วนการทำงานเล็ก ๆ แล้ว
ก็ยิ่งทำให้คุณภาพของการออกแบบระบบดีรวมทั้ง ลดความเสี่ยงจาก Merge conflict อีกด้วย
3. แก้ไขการ Merge conflict ได้ง่าย ๆ มากเลยนะเพียงแค่เราคุยกันในเรื่องที่ควรจะคุยกันมากขึ้น
16.) Git คือ Version Control ตัวหนึ่ง ซึ่งเป็นระบบที่มีหน้าที่ในการจัดเก็บการเปลี่ยนแปลงของไฟล์ในโปรเจ็คเรา มีการ backup code ให้เรา สามารถที่จะเรียกดูหรือย้อนกลับไปดูเวอร์ชั่นต่างๆของโปรเจ็คที่ใด เวลาใดก็ได้ หรือแม้แต่ดูว่าไฟล์นั้นๆใครเป็นคนเพิ่มหรือแก้ไข หรือว่าจะดูว่าไฟล์นั้นๆถูกเขียนโดยใครบ้างก็สามารถทำได้ ฉะนั้น Version Control ก็เหมาะอย่างยิ่งสำหรับนักพัฒนาไม่ว่าจะเป็นคนเดียวโดยเฉพาะอย่างยิ่งจะมีประสิทธิภาพมากหากเป็นการพัฒนาเป็นทีม
แตกต่างจาก Github คือ Github เป็นเว็บเซิฟเวอร์ที่ให้บริการในการฝากไฟล์ Git
17.) branch ก็เหมือนกับการก้อปปี้โค้ดที่อยู่ภายใน master ทั้งหมดไปเป็นอีกโฟลเดอร์หนึ่งแล้วตั้งชื่อใหม่ ทุกคนที่ร่วมกันทำงานก็ให้ตกลงกันว่าจะ commit, push โค้ดลงไปที่นี่ ทดสอบโค้ดกันที่นี่ พอหลังจากพัฒนาโค้ดจนดี ไม่มีบัก อยากจะขึ้นโปรดักชั่นแล้ว ค่อย merge เขาเรียกว่าการ merge โค้ดกลับเข้าไปยัง master
ซึ่งตัว git มันจะเช็กของมันเองว่ามีโค้ดส่วนไหนเปลี่ยนแปลงไปบ้าง มันจะทำการผสานโค้ดของมันเอง เราไม่ต้องไปยุ่งเกี่ยวอะไรกับมันเลย แล้ว git เองมันก็ฉลาดถึงขนาดที่ว่า มันรู้ว่า ลบบรรทัดไหน เพิ่มบรรทัดไหน
18.) "Fast forward" ใน merge นั้นคือ commit ที่ถูกชี้โดย branch ที่คุณ merge มันเป็น upstream ของ commit ที่คุณอยู่โดยตรง Git ก็เลยขยับ pointer ไปข้างหน้า พูดอีกนัยหนึ่งก็คือ เวลาที่คุณพยายามจะ merge commit ซักอันเข้ากับ commit ที่สามารถไปถึงได้โดยการตาม history ของ commit อันแรก Git จะทำให้ทุกอย่างง่ายขึ้นโดยการขยับ pointer ไปข้างหน้าเพราะมันไม่มีงานที่ถูกแยกออกไปให้ merge สิ่งนี้เรียกว่า "fast forward".
19.) ใช้ดึงความเปลี่ยนแปลงจาก remote มายัง local และรวมเข้าด้วยกัน (มีค่าเท่ากับ fetch+merge)
20. )  การแบ่งงานให้คนในทีมทำและแก้ไขส่วนต่างๆ
